import executeGenerator from "../utils/generatorExecutor";
import createZipFile from "../utils/zipFileCreator";
import handleExceptions from "../utils/globalExceptionHandler";
import lockFileAndContinue from "../utils/fileLockProcess";
import {fileExists, createTempDir} from "../utils/fileUtils";
import {getTempDir} from "../features/defaultWorkingDir";

const path = require('path');
const md5 = require("md5");

handleExceptions();

export class TemplateGenerator {
    constructor() {
    }

    /**
     * Build a file system safe hash that represents the generator and the specified options.
     * @param generator The name of the Yeoman generator.
     * @param options The options applied to the generator.
     * @param arguments The arguments applied to the generator.
     * @param args The arguments applied to the generator.
     * @param answers The answers applied to the generator.
     * @private
     */
    private async getTemplateId(
        generator: string,
        options: { [key: string]: string; },
        answers: { [key: string]: string; },
        args: string[]): Promise<string> {
        const id = generator
            + Object.keys(options || {}).sort().map(k => k + options[k]).join("")
            + Object.keys(answers || {}).sort().map(k => k + answers[k]).join("")
            + Object.keys(args || []).sort().join("");
        const hash = md5(id);
        return new Buffer(hash).toString('base64');
    }

    /**
     * Returns the path to a cached templated if it exists.
     * @param id The has of the generator and options generated by getTemplateId()
     */
    async getTemplate(id: string): Promise<string> {
        // This is where the template is created
        const zipPath = path.join(getTempDir(), id + '.zip');

        // If the template does nopt exist, build it
        if (fileExists(zipPath)) {
            return zipPath;
        }

        return "";
    }

    /**
     * Build the template and return the path to the ZIP file.
     * @param generator The name of the generator.
     * @param options The generator options.
     * @param answers The generator answers.
     * @param args The generator arguments.
     */
    async generateTemplateSync(
        generator: string,
        options: { [key: string]: string; },
        answers: { [key: string]: string; },
        args: string[]): Promise<string> {

        // Create a hash based on the generator and the options
        const hash = await this.getTemplateId(generator, options, answers, args);
        // This is where the template is created
        const zipPath = path.join(getTempDir(), hash + '.zip');

        await this.buildNewTemplate(generator, options, answers, args, zipPath);

        return zipPath;
    }

    /**
     * Generate a template in a background operation, and return the hash for use with getTemplate().
     * @param generator The name of the generator.
     * @param options The generator options.
     * @param answers The generator answers.
     * @param args The generator arguments.
     */
    async generateTemplate(
        generator: string,
        options: { [key: string]: string; },
        answers: { [key: string]: string; },
        args: string[]): Promise<string> {

        // Create a hash based on the generator and the options
        const hash = await this.getTemplateId(generator, options, answers, args);
        // This is where the template is created
        const zipPath = path.join(getTempDir(), hash + '.zip');

        // trigger the build, but don't wait for it
        this.buildNewTemplate(generator, options, answers, args, zipPath)
            .catch(e => console.log(e));

        return hash;
    }

    /**
     * Build the template and save it in a temporary directory.
     * @param generator The name of the generator.
     * @param options The generator options.
     * @param answers The generator answers.
     * @param args The generator argumnets.
     * @param zipPath The path to save the template to.
     */
    buildNewTemplate(
        generator: string,
        options: { [key: string]: string; },
        answers: { [key: string]: string; },
        args: string[],
        zipPath: string) {
        const lockFilePath = zipPath + ".lock";
        return lockFileAndContinue(lockFilePath, () => {
            if (!fileExists(zipPath)) {
                return this.writeTemplate(generator, options, answers, args, zipPath);
            }
            return zipPath;
        });
    }

    /**
     * Write the template to a file.
     * @param generator The name of the generator.
     * @param options The generator options.
     * @param answers The generator answers.
     * @param args The generator arguments.
     * @param zipPath The path to save the generator ZIP file to.
     * @private
     */
    private writeTemplate(
        generator: string,
        options: { [key: string]: string; },
        answers: { [key: string]: string; },
        args: string[],
        zipPath: string) {

        // sanity check the supplied arguments
        const fixedArgs = !!args && Array.isArray(args)
            ? args
            : [];

        const fixedOptions = options
            ? options
            : {};

        const fixedAnswers = answers
            ? answers
            : {};

        return createTempDir("template", (tempDir: string) => {
            return executeGenerator(generator, tempDir, fixedArgs, fixedOptions, fixedAnswers)
                .then(() => createZipFile(tempDir, zipPath))
                .catch((err) => {
                    console.log(err);
                    throw err;
                });
        });
    }
}
