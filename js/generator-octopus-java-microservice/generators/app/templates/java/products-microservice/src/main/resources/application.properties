# The port used when running as a web container
quarkus.http.port=${PORT:8083}
# HTTP tests bind to a random port
quarkus.http.test-port=0
# Bind to all interfaces
quarkus.http.host=0.0.0.0
# Note for Azure functions, this root path needs to be matched with a setting in host.json.
# See https://vincentlauzon.com/2018/02/14/how-to-get-rid-of-api-in-azure-functions-route/ for details.
quarkus.http.root-path=/
quarkus.package.type=uber-jar
# The name of the handler used to respond to Lambda requests. This can either be "ResourceHandler" or "DatabaseInit"
quarkus.lambda.handler=${LAMBDA_NAME:ResourceHandler}
quarkus.log.min-level=INFO
# Limit jacoco reports to the packages in this project.
quarkus.jacoco.includes=com/octopus/products/**
# https://github.com/oracle/graal/issues/3875
quarkus.native.additional-build-args=-J--add-exports=java.management/sun.management=ALL-UNNAMED
# Allow the HTTP interface to be accessed from other domains
quarkus.http.cors=true
# Allow credentials in CORS requests
quarkus.http.cors.access-control-allow-credentials=true
# Trust all TLS certs when making outbound connections
quarkus.tls.trust-all=true
# When debugging locally we ued an in memory H2 database
quarkus.datasource.db-kind=${DB_KIND:h2}
# Database username is optional, as it is not required for H2
quarkus.datasource.username=${DATABASE_USERNAME:}
# Database password is optional, as it is not required for H2
quarkus.datasource.password=${DATABASE_PASSWORD:}
# Start the in memory database, and do not close it
quarkus.datasource.jdbc.url=${DATABASE_JDBC:jdbc:h2:mem:default;DB_CLOSE_DELAY=-1}
# We use liquidbase rather than Hibernate to initialize the databases.
quarkus.hibernate-orm.database.generation=none
# MIGRATE_AT_START must be set to "true" when debugging locally, as this initializes the H2 database.
# It is set to false for Lambda deployments, as a Lambda running the "DatabaseInit" handler is run
# during deployment to migrate the database with any new changes.
quarkus.liquibase.migrate-at-start=${MIGRATE_AT_START:true}
# Set this to true to see the SQL statements generated by Hibernate.
quarkus.hibernate-orm.log.sql=false
# Set this to true to see the parameters included in SQL statements.
quarkus.hibernate-orm.log.bind-parameters=true
# These values are used when deploying the app to a container that uses a local mysql connection
%mysql.quarkus.datasource.db-kind=mysql
# The createDatabaseIfNotExist param ensures that liquidbase has a database to initially populate
%mysql.quarkus.datasource.jdbc.url=jdbc:mysql://${DATABASE_HOSTNAME}:${DATABASE_PORT:3306}/${DATABASE_NAME:product}?createDatabaseIfNotExist=true
# Database username is not optional when deploying to FaaS services
%mysql.quarkus.datasource.username=${DATABASE_USERNAME}
# Database password is not optional when deploying to FaaS services
%mysql.quarkus.datasource.password=${DATABASE_PASSWORD}
# These values are used when deploying the app to a FaaS service like Lambda
%faas.quarkus.datasource.db-kind=mysql
# The createDatabaseIfNotExist param ensures that liquidbase has a database to initially populate
%faas.quarkus.datasource.jdbc.url=jdbc:mysql://${DATABASE_HOSTNAME}:${DATABASE_PORT:3306}/${DATABASE_NAME:product}?enabledTLSProtocols=TLSv1.2&createDatabaseIfNotExist=true
# Database username is not optional when deploying to FaaS services
%faas.quarkus.datasource.username=${DATABASE_USERNAME}
# Database password is not optional when deploying to FaaS services
%faas.quarkus.datasource.password=${DATABASE_PASSWORD}
# Set this to true to disable all JWT based authentication and authorization. Disabling security is useful for local debugging.
cognito.disable-auth=${COGNITO_DISABLE_AUTH:true}
# A base64 encoded copy of the JWK
# Get the JWK from https://cognito-idp.{region}.amazonaws.com/{userPoolId}/.well-known/jwks.json
cognito.jwk-base64=${COGNITO_JWK:}
# The name of the scope used to grant access to the service. Leave the value blank if not using machine-to-machine communication.
cognito.admin-claim=${COGNITO_ADMIN_CLAIM:}
# The client ID of the Cognito app client used to generate client credentials (i.e. machine-to-machine) access tokens
cognito.client-id=${COGNITO_CLIENT_ID:unknown}
# The Cognito group an end user must be in to work with the API resources. Leave the value unset if not using RBAC.
cognito.admin-group=${COGNITO_ADMIN_GROUP:Developers}
