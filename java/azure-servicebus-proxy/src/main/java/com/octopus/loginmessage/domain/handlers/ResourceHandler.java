package com.octopus.loginmessage.domain.handlers;

import com.github.jasminb.jsonapi.JSONAPIDocument;
import com.github.jasminb.jsonapi.ResourceConverter;
import com.github.jasminb.jsonapi.exceptions.DocumentSerializationException;
import com.octopus.loginmessage.domain.entities.GithubUserLoggedInForFreeToolsEventV1;
import com.octopus.loginmessage.domain.entities.GithubUserLoggedInForFreeToolsEventV1Upstream;
import com.octopus.loginmessage.domain.entities.converters.GithubUserLoggedInForFreeToolsEventV1Converter;
import com.octopus.loginmessage.domain.features.impl.DisableSecurityFeatureImpl;
import com.octopus.loginmessage.infrastructure.octofront.CommercialServiceBus;
import com.octopus.exceptions.InvalidInputException;
import com.octopus.exceptions.UnauthorizedException;
import com.octopus.features.AdminJwtClaimFeature;
import com.octopus.features.AdminJwtGroupFeature;
import com.octopus.json.JsonSerializer;
import com.octopus.jwt.JwtInspector;
import com.octopus.jwt.JwtUtils;
import java.nio.charset.StandardCharsets;
import java.util.List;
import javax.enterprise.context.ApplicationScoped;
import javax.inject.Inject;
import lombok.NonNull;
import org.eclipse.microprofile.config.inject.ConfigProperty;

/**
 * Handlers take the raw input from the upstream service, like Lambda or a web server, convert the
 * inputs to POJOs, apply the security rules, and then pass the requests down to repositories.
 */
@ApplicationScoped
public class ResourceHandler {

  @Inject
  AdminJwtClaimFeature adminJwtClaimFeature;

  @ConfigProperty(name = "cognito.client-id")
  String cognitoClientId;

  @Inject
  DisableSecurityFeatureImpl cognitoDisableAuth;

  @Inject
  AdminJwtGroupFeature adminJwtGroupFeature;

  @Inject
  ResourceConverter resourceConverter;

  @Inject
  JwtInspector jwtInspector;

  @Inject
  JwtUtils jwtUtils;

  @Inject
  CommercialServiceBus commercialServiceBus;

  @Inject
  JsonSerializer jsonSerializer;

  @Inject
  GithubUserLoggedInForFreeToolsEventV1Converter githubUserLoggedInForFreeToolsEventV1Converter;

  /**
   * Creates a new resource.
   *
   * @param document                   The JSONAPI resource to create.
   * @param dataPartitionHeaders       The "Data-Partition" headers.
   * @param authorizationHeader        The "Authorization" headers.
   * @param serviceAuthorizationHeader The "Service-Authorization" headers.
   * @param xray                       The "X-Amzn-Trace-Id" headers.
   * @throws DocumentSerializationException Thrown if the entity could not be converted to a JSONAPI
   *                                        resource.
   */
  public void create(
      @NonNull final String document,
      @NonNull final List<String> dataPartitionHeaders,
      final String authorizationHeader,
      final String serviceAuthorizationHeader,
      final String xray) {

    if (!isAuthorized(authorizationHeader, serviceAuthorizationHeader)) {
      throw new UnauthorizedException();
    }

    /*
      The message we send upstream is a little different from the one our API receives. Notably,
      the upstream version does not have an ID field.
     */
    final GithubUserLoggedInForFreeToolsEventV1Upstream resource =
        githubUserLoggedInForFreeToolsEventV1Converter.from(getResourceFromDocument(document));
    commercialServiceBus.sendUserDetails(xray, jsonSerializer.toJson(resource));
  }

  private GithubUserLoggedInForFreeToolsEventV1 getResourceFromDocument(final String document) {
    try {
      final JSONAPIDocument<GithubUserLoggedInForFreeToolsEventV1> resourceDocument =
          resourceConverter.readDocument(
              document.getBytes(StandardCharsets.UTF_8),
              GithubUserLoggedInForFreeToolsEventV1.class);
      final GithubUserLoggedInForFreeToolsEventV1 resource = resourceDocument.get();
      return resource;
    } catch (final Exception ex) {
      // Assume the JSON is unable to be parsed.
      throw new InvalidInputException();
    }
  }

  /**
   * Determines if the supplied token grants the required scopes to execute the operation.
   *
   * @param authorizationHeader        The Authorization header.
   * @param serviceAuthorizationHeader The Service-Authorization header.
   * @return true if the request is authorized, and false otherwise.
   */
  private boolean isAuthorized(
      final String authorizationHeader,
      final String serviceAuthorizationHeader) {

    /*
      This method implements the following logic:
      * If auth is disabled, return true.
      * If the Service-Authorization header contains an access token with the correct scope,
        generated by a known app client, return true.
      * If the Authorization header contains a known group, return true.
      * Otherwise, return false.
     */

    if (cognitoDisableAuth.getCognitoAuthDisabled()) {
      return true;
    }

    /*
      An admin scope granted to an access token generated by a known client credentials
      app client is accepted as machine-to-machine communication.
     */
    if (adminJwtClaimFeature.getAdminClaim().isPresent() && jwtUtils.getJwtFromAuthorizationHeader(
            serviceAuthorizationHeader)
        .map(jwt -> jwtInspector.jwtContainsScope(jwt, adminJwtClaimFeature.getAdminClaim().get(),
            cognitoClientId))
        .orElse(false)) {
      return true;
    }

    /*
      Anyone assigned to the appropriate group is also granted access.
     */
    return adminJwtGroupFeature.getAdminGroup().isPresent()
        && jwtUtils.getJwtFromAuthorizationHeader(authorizationHeader)
        .map(jwt -> jwtInspector.jwtContainsCognitoGroup(jwt,
            adminJwtGroupFeature.getAdminGroup().get()))
        .orElse(false);
  }
}
